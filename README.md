# clecs

A proof of concept for a device-resident ECS framework using OpenCL, C++17 and CMake. Components live directly in device memory, and systems are executed as compute kernels. The host only fetches data via an async API.

## Features

- Component data stored entirely on device
- Systems run as OpenCL kernels, directly modifying device memory
- Async host access to device-resident data via `std::future`
- CMake-based component/system codegen from declarative JSON and OpenCL C

## Usage

Define components using JSON :

```json
{
  "name": "position",
  "fields": {
    "x": "float",
    "y": "float",
    "z": "float"
  }
}
```

Define systems using OpenCL C :

```c++
#include "position.cl"                      // generated by codegen from JSON

kernel void smain(__global position* positions)
{
    int k = get_global_id(0);
    positions[k].x = 1.2f + positions[k].x;
    positions[k].y = 1.4f + positions[k].y;
    positions[k].z = 1.6f + positions[k].z;
}
```

Link and call codegen from CMake :

```cmake
add_subdirectory(cl_ecs)
target_link_libraries(MY_TARGET PRIVATE cl_ecs)

target_link_components(MY_TARGET
    ${CMAKE_CURRENT_LIST_DIR}/component     # path to a folder containing components as JSON
    ${CMAKE_CURRENT_LIST_DIR}/.gen          # path to a folder for generated components
)
    
target_link_systems(MY_TARGET  
    ${CMAKE_CURRENT_LIST_DIR}/system        # path to a folder containing systems as OpenCL C
    ${CMAKE_CURRENT_LIST_DIR}/.gen          # path to a folder for generated systems
)

```

Use the ECS APIs :

```c++
#include <compute/ecs/registry.hpp>

#include "position.hpp"                     // generated dir is in included dirs
#include "speed.hpp"                        // generated dir is in included dirs

#include <iostream>

void print(const position& pos)
{
    std::cout << "x = " << pos.x << " y = " << pos.y << " z = " << pos.z;
    std::cout << std::endl;
}

int main()
{
    auto _device = compute::device::get_device(0);
    auto _context = compute::context(_device);
    std::cout << "device name : " << _device.get_name() << std::endl;

    auto _registry = compute::registry(_context, 1024);
    auto _entity = _registry.create_entity();
    _registry.add_component<position>(_entity, position{});

    print(_registry.get_component<position>(_entity).get());
    _registry.execute_system<speed, position>();
    print(_registry.get_component<position>(_entity).get());

    return 0;
}
```
